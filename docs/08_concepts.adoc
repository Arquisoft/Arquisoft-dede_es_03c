== Domain model

[options="header",cols="1,2,2"]
|===
|Name|Description
| Client | User who choose and buy products
| POD | User's information
| Order | Keep a list of the products that the customer has ordered.
| Product | Contains information about a product, such as name and price.
| ProductInOrder | Product associated with an order, saves the quantity that the customer wants of the product.
| Distribution Center | Place from where the products are distributed, contains the address of the distribution center.
|===

image:08_umldiagram.png["Domain Model - UML Diagram"]

=== Persistence

At the beginning there was a debate about whether it was better to use SQL or NoSQL for persistence. After some discussion it was concluded that the best option for this problem is NoSQL. To be more specific MongoDB, which is a NoSQL document database. We will use a NoSQL database as opposed to a SQL database, because our model encompasses many products. These products have several attributes which are very different. For example, a power supply differs in many ways from a graphics card. Because there are so many items, we believe it is best to use a NoSQL DB. But, because of our hexagonal architecture, we can switch from NoSQL to SQL without needing to modify the code, or switch from MongoDB to Cassandra, the change doesn't matter because the backend is not related to the persistence used

=== User interface

_DeDe user interface is desinged to give every user an intuitive and familiar experience related using the React framework combined with TypeScript as constraints. We follow the usual standards of e-commerce online sites to make the navigation closer to what most of the people already know. Also, the interface is meant to pass the AAA validation so we make sure it's usable for almost everyone_

image:08_UI-Homepage.png["Homepage prototype"]
image:08_UI-OtherWindows.png["Other Functionalities"]

=== Internazionalization

The application will potentially deal with various locations and people, so make a multi-language application looks like the best decision. This decision must be done since the begining of the desing (lately will cost a lot of resources).

This allows us to reach a bigger audience and make the application more accesible.


=== Security

For security we have used an asynchronous encryption algorithm called PBKDF2, which is one of the most famous KDF encryption algorithms. The user will put a password in plain text, which will be encrypted using a Hash function, a salt will be added to it, which is a random number added at the beginning of the password, all this string will be saved in the database, achieving a very high level of security.
We have a role system, which defines if a user is an Administrator or a normal User, and depending on that he will have one or other options enabled, such as a CRUD of products or users, to avoid a scale of privileges we have made it impossible to be Admin, it always inserts users as User and we have a couple of Administrators created by default.

=== Additional libraries

TODO


=== Archiutecture and design patterns

TODO


=== Code Quality standards

Code quality standars allows us to make an understable, maintainable and reusable code for future revisions and changes. Code should always have a correct structure to be easily understandable.

To achieve this we will use all tools programs give us and make correct decisions like design patters, use convention naming and try to reduce technical debt.

=== Testability

Applications should be strongly tested. We will use user histories to make acceptance tests and unit test to test the rest of the application components and states during running process.
We think this is the best way to be sure the project works correctly.

To test our code, Postman was used in the backend during the whole development of the work, to check if the requests were being carried out correctly. Later, once we had a more or less solid project, we added a series of unit tests, which use Jest technology, these tests try to include all the backend and frontend parts, but separately, without joining them. Once these tests passed successfully, integration tests were implemented, which test the union of frontend and backend, all these tests were done exhaustively and were performed by people who had not done that part of the code, with that we get that we do not test things that are known to work. 
